---
title: 几种常见的加密方式
date: 2016-03-08 22:36:33
tags: 网络完全
categories: 技术
---

## 数据加密(Data encryption)

数据加密，是一门历史悠久的技术，指通过[加密算法](http://baike.baidu.com/view/155969.htm)和加密[密钥](http://baike.baidu.com/view/934.htm)将明文转变为密文，而解密则是通过解密算法和解密密钥将密文恢复为明文。它的核心是密码学。

数据加密目前仍是[计算机系统](http://baike.baidu.com/view/1130583.htm)对信息进行保护的一种最可靠的办法。它利用[密码技术](http://baike.baidu.com/view/391036.htm)对信息进行加密，实现[信息隐蔽](http://baike.baidu.com/view/431307.htm)，从而起到保护信息的安全的作用。 

<!-- more -->

## Base64加密方式(可逆)

#### **什么是Base64**

Base64编码可以成为密码学的基石。可以将任意的二进制数据进行Base64编码。所有的数据都能被编码为并只用65个字符就能表示的文本文件。（ 65字符：A~Z a~z 0~9 + / = ）等号“=”用来作为后缀用途。编码后的数据~=编码前数据的4/3，会大1/3左右。

#### **在bash中使用Base64:**

```sh
base64 需要加密的文件 -o 加密后的文件 #加密过程
base64 加密后的文件 -o 解密后的文件 -D #解密过程
```

#### **Base64编码原理**

```TXT
a.将所有字符转化为ASCII码； 

b.将ASCII码转化为8位二进制； 

c.将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位； 

d.统一在6位二进制前补两个0凑足8位； 

e.将补0后的二进制转为十进制； 

f.从Base64编码表获取十进制对应的Base64编码； 

```

#### **Base64编码的说明** 

```TXT
a.转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。 

b.数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。 

c.不断进行，直到全部输入数据转换完成。 

d.如果最后剩下两个输入数据，在编码结果后加1个“=”； 

e.如果最后剩下一个输入数据，编码结果后加2个“=”； 

f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。

```

##  散列函数加密（不可逆）

#### 散列函数：

**散列函数**（或**散列算法**，又称**哈希函数**，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)将数据打乱混合，重新创建一个叫做**散列值**（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现[散列冲突](https://zh.wikipedia.org/w/index.php?title=%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81&action=edit&redlink=1)。在[散列表](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8)和[数据处理](https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&action=edit&redlink=1)中，不抑制冲突来区别数据，会使得[数据库记录](https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%B0%E5%BD%95&action=edit&redlink=1)更难找到。

#### 单向散列函数：

如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有[确定性](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%80%A7)的结果，具有这种性质的散列函数称为单向散列函数。

#### 哈希碰撞：

另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“哈希碰撞”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。

#### 密码散列函数：

**密码散列函数**（英语：Cryptographic hash function），又译为**加密散列函数**、**密码散列函数**、**加密散列函数**，是[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)的一种。它被认为是一种[单向函数](https://zh.wikipedia.org/wiki/%E5%96%AE%E5%90%91%E5%87%BD%E6%95%B8)，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么。这样的单向函数被称为“现代密码学的驮马”。[[1\]](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8#cite_note-1)这种散列函数的输入数据，通常被称为**消息**（message），而它的输出结果，经常被称为**消息摘要**（message digest）或**摘要**（digest）。

一个理想的密码散列函数应该有四个主要的特性：

- 对于任何一个给定的消息，它都很容易就能运算出散列数值
- [难以](https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E8%A4%87%E9%9B%9C%E6%80%A7%E7%90%86%E8%AB%96)由一个已知的散列数值，去推算出原始的消息
- 在不更动散列数值的前提下，修改消息内容是不可行的
- 对于两个不同的消息，它不能给与相同的散列数值

![](http://wx3.sinaimg.cn/mw1024/6aae3cf3ly1fdfvfa72vwj20hs0cwq4m.jpg)

一个工作中的密码散列函数 (特定的, [SHA-1](https://zh.wikipedia.org/wiki/SHA-1))。注意，源输入再微小的变化（“over”这个词）也会使所产生的输出发生急剧变化，通过所谓的[雪崩效应](https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94_(%E5%AF%86%E7%A0%81%E5%AD%A6))的原理。

### 碰撞（计算机科学）

在计算机科学中，碰撞或冲突是指两个不同的元素具有相同的[哈希值](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E5%80%BC)，[校验和](https://zh.wikipedia.org/wiki/%E6%A0%A1%E9%AA%8C%E5%92%8C)，数字指纹时发生的情况。当数据量足够多（例如将所有可能的人名和计算机文件名映射到一段字符上）时，碰撞是不可避免的。这仅仅是[鸽巢原理](https://zh.wikipedia.org/wiki/%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86)的一个实例。

### 消息认证码

在[密码学](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8)中，**消息认证码**（英语：Message authentication code，缩写为MAC），又译为**消息鉴别码**、**文件消息认证码**、**讯息鉴别码**、**信息认证码**，是经过特定算法后产生的一小段信息，检查某段消息的[完整性](https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%95%B4%E6%80%A7)，以及作[身份验证](https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)。它可以用来检查在消息传递过程中，其内容是否被更改过，不管更改的原因是来自意外或是蓄意攻击。同时可以作为消息来源的[身份验证](https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)，确认消息的来源。

消息认证码的算法中，通常会使用[带密钥的散列函数（HMAC）](https://zh.wikipedia.org/wiki/%E9%87%91%E9%91%B0%E9%9B%9C%E6%B9%8A%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC)，或者块密码的带认证工作模式（如CBC-MAC）。

信息鉴别码不能提供对信息的保密，若要同时实现保密认证，同时需要对信息进行加密。

### 彩虹表

**彩虹表**是一个用于[加密散列函数](https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)逆运算的[预先计算](https://zh.wikipedia.org/w/index.php?title=%E9%A2%84%E5%85%88%E8%AE%A1%E7%AE%97&action=edit&redlink=1)好的[表](https://zh.wikipedia.org/wiki/%E6%9F%A5%E6%89%BE%E8%A1%A8)，常用于破解加密过的密码散列。 查找表常常用于包含有限字符固定长度[纯文本](https://zh.wikipedia.org/w/index.php?title=%E7%BA%AF%E6%96%87%E6%9C%AC&action=edit&redlink=1)[密码](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81)的加密。这是[以空间换时间](https://zh.wikipedia.org/wiki/%E4%BB%A5%E7%A9%BA%E9%96%93%E6%8F%9B%E6%99%82%E9%96%93)的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。使用[加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6))的[KDF函数](https://zh.wikipedia.org/w/index.php?title=KDF%E5%87%BD%E6%95%B0&action=edit&redlink=1)可以使这种攻击难以实现。

### 暴力破解法

#### 1. 暴力破解法

**暴力破解法**，或称为**穷举法**，是一种[密码分析](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90)的方法，即将密码进行逐个推算直到找出真正的密码为止。例如一个已知是四位并且全部由[数字](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97)组成的密码，其可能共有10000种组合，因此最多尝试9999次就能找到正确的密码。理论上除了具有[完善保密性](https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%96%84%E4%BF%9D%E5%AF%86%E6%80%A7)的密码以外，利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。有些人运用[计算机](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA)来增加效率，有些人辅以[字典](https://zh.wikipedia.org/wiki/%E5%AD%97%E5%85%B8)来缩小密码组合的范围。

#### 2. 防护手段

最重要的手段是在构建系统时要将系统设计目标定为即便受到暴力破解的攻击也难以被攻破。以下列举了一些常用的防护手段：

- 增加密码的长度与复杂度
- 在系统中限制密码试错的次数
- 密码验证时，将验证结果不是立即返回而是延时若干秒后返回。
- 限制允许发起请求的客户端的范围
- 禁止密码输入频率过高的请求
- 将密码设置为类似[安全令牌](https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E4%BB%A4%E7%89%8C)那样每隔一定时间就发生变化的形式
- 当同一来源的密码输入出错次数超过一定阈值，立即通过邮件/短信等方式通知系统管理员
- 人为监视系统，确认有无异常的密码试错。

### <font color="red">MD5加密(32位散列值)</font>

#### MD5：

**MD5消息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的[密码散列函数](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8)，可以产生出一个128位（16[字节](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82)）的散列值（hash value），用于确保信息传输完整一致。MD5由[罗纳德·李维斯特](https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9)设计，于1992年公开，用以替换[MD4](https://zh.wikipedia.org/wiki/MD4)算法。这套算法的程序在 [RFC 1321](https://tools.ietf.org/html/rfc1321) 中被加以规范。

1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如[SHA-1](https://zh.wikipedia.org/wiki/SHA-1)。2004年，证实MD5算法无法防止碰撞，因此无法适用于安全性认证，如[SSL](https://zh.wikipedia.org/wiki/SSL)[公开密钥认证](https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89)或是[数字签名](https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0)等用途。

#### 应用：

MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。如在一些[BitTorrent](https://zh.wikipedia.org/wiki/BitTorrent)下载中，软件将通过计算MD5检验下载到的文件片段的完整性。

MD5亦有应用于部分网上赌场以保证赌博的公平性，原理是系统先在玩家下注前已生成该局的结果，将该结果的字符串配合一组随机字符串利用MD5 加密，将该加密字符串于玩家下注前便显示给玩家，再在结果开出后将未加密的字符串显示给玩家，玩家便可利用MD5工具加密验证该字符串是否吻合。

例子: 在玩家下注骰宝前，赌场便先决定该局结果，假设生成的随机结果为4、5、 6大，赌场便会先利用MD5 加密“4, 5, 6”此字符串并于玩家下注前告诉玩家；由于赌场是无法预计玩家会下什么注，所以便能确保赌场不能作弊；当玩家下注完毕后，赌场便告诉玩家该原始字符串，即“4, 5, 6”，玩家便可利用MD5工具加密该字符串是否与下注前的加密字符串吻合。

该字符串一般会加上一组随机字符串 (Random string)，以防止玩家利用碰撞 (Collision) 解密字符串，但如使用超级电脑利用碰撞亦有可能从加上随机字符串的加密字符串中获取游戏结果。随机字符串的长度与碰撞的次数成正比关系，一般网上赌场使用的随机字符串是长于20字，有些网上赌场的随机字符串更长达500字，以增加解密难度。

#### 算法：

MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits[散列](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97)。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。

#### 特点：

1. 压缩性：任意长度的数据，算出的MD5值长度都是固定的(32位)。
2. 容易计算：从原数据计算出MD5值很容易。
3. 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
4. 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的（但也会被碰撞）。

#### bash中使用MD5

```sh
md5 -s "需要md5加密的字符串" #md5加密字符串
md5 文件 #md5加密文件
```

#### 缺陷：

2009年[谢涛](https://zh.wikipedia.org/wiki/%E8%AC%9D%E6%BF%A4)和冯登国仅用了220.96的碰撞算法复杂度，破解了MD5的[碰撞抵抗](https://zh.wikipedia.org/w/index.php?title=%E7%A2%B0%E6%92%9E%E6%8A%B5%E6%8A%97&action=edit&redlink=1)，该攻击在普通计算机上运行只需要数秒钟。

### <font color="red">盐(密码学)</font>

#### 加盐：

**盐**（Salt），在[密码学](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6)中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。

#### 为什么加盐：

通常情况下，当字段经过散列处理（如[MD5](https://zh.wikipedia.org/wiki/MD5)），会生成一段散列值，而散列后的值一般是无法通过特定算法得到原始字段的。但是某些情况，比如一个大型的[彩虹表](https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8)，通过在表中搜索该MD5值，很有可能在极短的时间内找到该散列值对应的真实字段内容。

加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。

#### 实现原理：

加盐的实现过程通常是在需要散列的字段的特定位置增加特定的字符，打乱原始的字符串，使其生成的散列结果产生变化。比如，用户使用了一个密码：

```
x7faqgjw
```

经过MD5散列后，可以得出结果：

```
455e0e5c2bc109deae749e7ce0cdd397
```

但是由于用户密码位数不足，短密码的散列结果很容易被[彩虹表](https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8)破解，因此，在用户的密码末尾添加特定字符串（括号内的字体为加盐的字段）：

```
x7faqgjw(abcdefghijklmnopqrstuvwxyz)
```

因此，加盐后的密码位数更长了，散列的结果也发生了变化：

```
4a1690d5eb6c126ef68606dda68c2f79
```

以上就是加盐过程的简单描述，在实际使用过程中，还需要通过特定位数插入、倒序或多种方法对原始密码进行固定的加盐处理，使得散列的结果更加不容易被破解或轻易得到原始密码，比如（括号内的字体为加盐字符串）：

```
x7(a)fa(b)qg(c)jw
```

### 十六进制

**十六进制**（简写为*hex*或下标16）在[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6)中是一种逢16进1的[进位制](https://zh.wikipedia.org/wiki/%E8%BF%9B%E4%BD%8D%E5%88%B6)。一般用数字0到9和字母A到F（或a~f）表示，其中:A~F表示10~15，这些称作**十六进制数字**。

### <font color="red">SHA-1（40位散列值）</font>

**SHA-1**（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种[密码散列函数](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)，[美国国家安全局](https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%AE%89%E5%85%A8%E5%B1%80)设计，并由美国[国家标准技术研究所](https://zh.wikipedia.org/wiki/%E5%9C%8B%E5%AE%B6%E6%A8%99%E6%BA%96%E6%8A%80%E8%A1%93%E7%A0%94%E7%A9%B6%E6%89%80)（NIST）发布为[联邦数据处理标准](https://zh.wikipedia.org/wiki/%E8%81%AF%E9%82%A6%E8%B3%87%E6%96%99%E8%99%95%E7%90%86%E6%A8%99%E6%BA%96)（FIPS）[[2\]](https://zh.wikipedia.org/wiki/SHA-1#cite_note-:0-2)。SHA-1可以生成一个被称为消息摘要的160[位](https://zh.wikipedia.org/wiki/%E4%BD%8D)（20[字节](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82)）散列值，散列值通常的呈现形式为40个[十六进制](https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6)数。(现已经被破解，可碰撞)

### <font color="red">SHA-2</font>

#### 特点：

1. 安全，目前为止没有被成功碰撞
2. 快速

#### 应用：

SHA-2 + 盐值 共同用于密码的保存。

#### java实现：

通过<font color="red">org.apache.commons.codec.digest.DigestUtils</font>类实现。直接调用静态加密方法。

```java
import org.apache.commons.codec.digest.DigestUtils; //导入包
String md5=DigestUtils.md5Hex("需要加密的数据"); //md5加密（32位散列值）
String sha256=DigestUtils.sha256Hex("需要加密的数据"); //sha256加密（64位）
String sha384=DigestUtils.sha384Hex("需要加密的数据"); //sha384加密（96位）
String sha512=DigestUtils.sha512Hex("需要加密的数据"); //sha512加密（128位）
```

## 钥匙串加密方式

iCloud钥匙串,苹果给我们提供的密码保存的解决方案,iOS7之后有的

存沙盒：

1、如果手机越狱，密码容易被窃取。

2、当软件更新时，沙盒里的内容是不被删除的。但是，如果将软件卸载后重装，沙盒里的数据就没有了。

3、每个APP的沙盒是相对独立的，密码无法共用。

存钥匙串里：

1、苹果提供的安全方案，rsa加密，相对安全。

2、无论软件更新或删除，密码都存在，都可以自动登录。

3、同一公司的APP密码是可以共用的。

## 对称加密算法（可逆）

优点：算法公开、计算量小、加密速度快、加密效率高、可逆

缺点：双方使用相同钥匙，安全性得不到保证

现状：对称加密的速度比公钥加密快很多，在很多场合都需要对称加密，

算法: 在对称加密算法中常用的算法有：[DES](http://baike.baidu.com/view/7510.htm)、[3DES](http://baike.baidu.com/view/350958.htm)、TDEA、[Blowfish](http://baike.baidu.com/view/2208941.htm)、RC2、RC4、[RC5](http://baike.baidu.com/view/734720.htm)、[IDEA](http://baike.baidu.com/view/92629.htm)、SKIPJACK、AES等。不同算法的实现机制不同，可参考对应算法的详细资料

相较于DES和3DES算法而言，AES算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准

nECB ：电子代码本，就是说每个块都是独立加密的

nCBC ：密码块链，使用一个密钥和一个初始化向量 (IV)对数据执行加密转换

ECB和CBC区别：CBC更加复杂更加安全，里面加入了8位的向量（8个0的话结果等于ECB）。在明文里面改一个字母，ECB密文对应的那一行会改变，CBC密文从那一行往后都会改变。

![](http://wx4.sinaimg.cn/mw1024/6aae3cf3ly1fdfu3mtjaxj212i0fuaeb.jpg)

### <font color="red">DES(Data Encryption Standard) 对称加密算法</font>

#### DES算法的入口参数有三个：**Key、Data、Mode**。

1. Key为8个字节共64位，是DES算法的工作密钥；
2. Data也为8个字节64位，是要被加密或被解密的数据；
3. Mode为DES的工作方式，有两种：加密或解密。

#### 应用：

为了网络上信息传输的安全（防止第三方窃取信息看到明文），发送发和接收方分别进行加密和解密，这样信息在<font color="red">网络上传输(比如银行卡号)</font>的时候就是相对安全的。

#### java实现DES:

```java
import org.apache.xerces.impl.dv.util.Base64;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import javax.crypto.SecretKey;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

/**
 * DES加密介绍 DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。DES加密算法出自IBM的研究，
 * 后来被美国政府正式采用，之后开始广泛流传，但是近些年使用越来越少，因为DES使用56位密钥，以现代计算能力，
 * 24小时内即可被破解。虽然如此，在某些简单应用中，我们还是可以使用DES加密算法，本文简单讲解DES的JAVA实现 。
 * 注意：DES加密和解密过程中，密钥长度都必须是8
 */
public class DES {
    private static final String ALGORITHM="DES";
    public static void main(String args[]) throws Exception, NoSuchAlgorithmException {
        // data 待加密内容
        String str = "3456789567890";
        // key 密匙，DES的密钥长度只能是8字节
        String password = "12345678";
        // DES算法要求有一个可信任的随机数源
        SecureRandom random = new SecureRandom();
        SecretKey securekey = new SecretKeySpec(password.getBytes(), ALGORITHM);
        // Cipher对象实际完成加密操作
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.ENCRYPT_MODE, securekey, random);
        // 现在，获取数据并加密
        // 正式执行加密操作
        byte[] result = cipher.doFinal(str.getBytes());
        //转换为String传输
        String text = Base64.encode(result);
        System.out.println("暗文：" + text);
        //解密
        cipher.init(Cipher.DECRYPT_MODE, securekey, random);
        byte[] de = cipher.doFinal(Base64.decode(text));
        System.out.println("明文" + new String(de));

    }
```

### <font color="red">AES(Advanced Encryption Standard)</font>

#### 介绍：

这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。

AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特，对应的也就是16字节、24字节、32字节。

#### 特点：

相对安全，推荐使用AES替代DES.

#### java实现AES:

```java
import org.apache.xerces.impl.dv.util.Base64;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import javax.crypto.SecretKey;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

/**
 *  这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。
 *  AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特，对应的也就是16字节、24字节、32字节。
 */
public class AES {
    private static final String ALGORITHM="AES";
    // 测试
    public static void main(String args[]) throws Exception, NoSuchAlgorithmException {
        // data 待加密内容
        String str = "3456789567890";
        // key 密匙，AES的密钥长度只能是16字节、24字节、32字节
        String password = "1234567891111111";

        // AES算法要求有一个可信任的随机数源
        SecureRandom random = new SecureRandom();
        SecretKey securekey = new SecretKeySpec(password.getBytes(), ALGORITHM);
        // Cipher对象实际完成加密操作
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.ENCRYPT_MODE, securekey, random);
        // 现在，获取数据并加密
        // 正式执行加密操作
        byte[] result = cipher.doFinal(str.getBytes());
        //转换为String传输
        String text = Base64.encode(result);
        System.out.println("暗文：" + text);
        //解密
        cipher.init(Cipher.DECRYPT_MODE, securekey, random);
        byte[] de = cipher.doFinal(Base64.decode(text));
        System.out.println("明文" + new String(de));

    }

```

## 非对称加密算法(Secruty.framework系统库)（可逆）

非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）

非对称加密中使用的主要算法有：[RSA](http://baike.baidu.com/view/7520.htm)、[Elgamal](http://baike.baidu.com/view/2154827.htm)、背包算法、Rabin、D-H、[ECC](http://baike.baidu.com/view/46554.htm)（椭圆曲线加密算法）等。

公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密

特点：

非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快

对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了

但是RSA加密算法效率较差，对大型数据加密时间很长，一般用于小数据。

![](http://wx4.sinaimg.cn/mw1024/6aae3cf3ly1fdfu3n2tsgj214g0f8gqi.jpg)

